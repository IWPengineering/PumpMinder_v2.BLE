/* This file was generated by plugin 'Nordic Semiconductor nRF5x v.1.2.2' (BDS version 1.0.2095.0) */

#include "ble_display_service.h"
#include <string.h>
#include "nordic_common.h"
#include "ble_srv_common.h"
#include "app_util.h"
#include "app_util_bds.h"

#define OPCODE_LENGTH 1 /**< Length of opcode inside Display Service packet. */
#define HANDLE_LENGTH 2 /**< Length of handle inside Display Service packet. */

/* TODO Consider changing the max values if encoded data for characteristic/descriptor is fixed length */ 
#define MAX_RECORD_NUMBER_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Record Number. */ 
#define MAX_RECORD_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Record. */ 

/**@brief Function for encoding Record Number.
 *
 * @param[in]   p_record_number              Record Number characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t record_number_encode(ble_display_service_record_number_t * p_record_number, uint8_t * encoded_buffer)
{
	uint8_t len = 0; 
	encoded_buffer[len++] = p_record_number->record_number;
	return len;
}

/**@brief Function for decoding Record Number.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t record_number_decode(uint8_t data_len, uint8_t * p_data, ble_display_service_record_number_t * p_write_val)
{
	uint8_t pos = 0;
	p_write_val->record_number = p_data[pos++]; 

	return pos;
} 
/**@brief Function for encoding Record.
 *
 * @param[in]   p_record              Record characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t record_encode(ble_display_service_record_t * p_record, uint8_t * encoded_buffer)
{
	uint8_t len = 0; 
	encoded_buffer[len++] = p_record->record_number;
	len += bds_uint32_encode(&p_record->seconds_running, &encoded_buffer[len]); 
	len += bds_uint32_encode(&p_record->timestamp, &encoded_buffer[len]); 
	return len;
}


/**@brief Function for handling the Connect event.
 *
 * @param[in]   p_display_service       Display Service Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_connect(ble_display_service_t * p_display_service, ble_evt_t * p_ble_evt)
{
	p_display_service->conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
}

/**@brief Function for handling the Disconnect event.
 *
 * @param[in]   p_display_service       Display Service Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_disconnect(ble_display_service_t * p_display_service, ble_evt_t * p_ble_evt)
{
	UNUSED_PARAMETER(p_ble_evt);
	p_display_service->conn_handle = BLE_CONN_HANDLE_INVALID;
}

/**@brief Function for handling the Write event.
 *
 * @param[in]   p_display_service       Display Service Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_write(ble_display_service_t * p_display_service, ble_gatts_evt_write_t * p_ble_evt)
{
    
	if (p_ble_evt->handle == p_display_service->record_number_handles.value_handle)
	{
		if (p_display_service->evt_handler != NULL)
		{
			ble_display_service_evt_t evt;
			evt.evt_type = BLE_DISPLAY_SERVICE_RECORD_NUMBER_EVT_WRITE;
			record_number_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.record_number);
			p_display_service->evt_handler(p_display_service, &evt);
		}
	}
	if (p_ble_evt->handle == p_display_service->record_handles.cccd_handle)
	{
		if (p_display_service->evt_handler != NULL)
		{
			ble_display_service_evt_t evt;
			evt.evt_type = BLE_DISPLAY_SERVICE_RECORD_EVT_CCCD_WRITE;
			bds_uint16_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cccd_value);
			p_display_service->evt_handler(p_display_service, &evt);
		}
	} 
}

/**@brief Authorize WRITE request event handler.
 *
 * @details Handles WRITE events from the BLE stack.
 *
 * @param[in]   p_sc_ctrlpt  SC Ctrlpt structure.
 * @param[in]   p_gatts_evt  GATTS Event received from the BLE stack.
 *
 */
static void on_rw_authorize_request(ble_display_service_t * p_display_service, ble_gatts_evt_t * p_gatts_evt)
{
	ble_gatts_evt_rw_authorize_request_t * p_auth_req = &p_gatts_evt->params.authorize_request;
	if (p_auth_req->type == BLE_GATTS_AUTHORIZE_TYPE_WRITE)
	{
		if ((p_gatts_evt->params.authorize_request.request.write.op
		        != BLE_GATTS_OP_PREP_WRITE_REQ)
			&& (p_gatts_evt->params.authorize_request.request.write.op
			    != BLE_GATTS_OP_EXEC_WRITE_REQ_NOW)
			&& (p_gatts_evt->params.authorize_request.request.write.op
			    != BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL))
		{
        
			if (p_auth_req->request.write.handle == p_display_service->record_number_handles.value_handle)
			{
				on_write(p_display_service, &p_auth_req->request.write);
			}
		}
	}
}

/**@brief Function for handling BLE events.
 *
 * @param[in]   p_display_service       Display Service Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
void ble_display_service_on_ble_evt(ble_display_service_t * p_display_service, ble_evt_t * p_ble_evt)
{
	switch (p_ble_evt->header.evt_id)
	{
	case BLE_GAP_EVT_CONNECTED:
		on_connect(p_display_service, p_ble_evt);
		break;
	case BLE_GAP_EVT_DISCONNECTED:
		on_disconnect(p_display_service, p_ble_evt);
		break;
	case BLE_GATTS_EVT_WRITE:
		on_write(p_display_service, &p_ble_evt->evt.gatts_evt.params.write);
		break;
	case BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST:
		on_rw_authorize_request(p_display_service, &p_ble_evt->evt.gatts_evt);
		break;
	default:
	    //No implementation needed.
		break;
	}
}

/**@brief Function for initializing the Display Service. */
uint32_t ble_display_service_init(ble_display_service_t * p_display_service, const ble_display_service_init_t * p_display_service_init)
{
	uint32_t err_code;
	ble_uuid_t ble_uuid;

	    // Initialize service structure
	p_display_service->evt_handler = p_display_service_init->evt_handler;
	p_display_service->conn_handle = BLE_CONN_HANDLE_INVALID;
    
	// Add a custom base UUID.
	ble_uuid128_t bds_base_uuid = { { 0x22, 0x13, 0xDC, 0x64, 0xC5, 0x14, 0x2B, 0x90, 0x0C, 0x43, 0xCF, 0x10, 0x00, 0x00, 0x00, 0x0D } };
	uint8_t       uuid_type;
	err_code = sd_ble_uuid_vs_add(&bds_base_uuid, &uuid_type);
	if (err_code != NRF_SUCCESS)
	{
		return err_code;
	}
	ble_uuid.type = uuid_type;
	ble_uuid.uuid = 0x14CE;
        
	// Add service
	err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_display_service->service_handle);
	if (err_code != NRF_SUCCESS)
	{
		return err_code;
	} 

	    // Add Record Number characteristic
	ble_display_service_record_number_t record_number_initial_value = p_display_service_init->ble_display_service_record_number_initial_value; 

	uint8_t record_number_encoded_value[MAX_RECORD_NUMBER_LEN];
	ble_add_char_params_t add_record_number_params;
	memset(&add_record_number_params, 0, sizeof(add_record_number_params));
    
	add_record_number_params.uuid                = 0xAF2A;
	add_record_number_params.uuid_type           = ble_uuid.type; 
	add_record_number_params.max_len             = MAX_RECORD_NUMBER_LEN;
	add_record_number_params.init_len            = record_number_encode(&record_number_initial_value, record_number_encoded_value);
	add_record_number_params.p_init_value        = record_number_encoded_value; 
	add_record_number_params.char_props.write    = 1; 
	add_record_number_params.char_props.write_wo_resp    = 1; 
	add_record_number_params.write_access        = SEC_OPEN; 
	// 1 for variable length and 0 for fixed length.
	add_record_number_params.is_var_len          = 1; 

	err_code = characteristic_add(p_display_service->service_handle, &add_record_number_params, &(p_display_service->record_number_handles));
	if (err_code != NRF_SUCCESS)
	{
		return err_code;
	} 

	    // Add Record characteristic
	ble_display_service_record_t record_initial_value = p_display_service_init->ble_display_service_record_initial_value; 

	uint8_t record_encoded_value[MAX_RECORD_LEN];
	ble_add_char_params_t add_record_params;
	memset(&add_record_params, 0, sizeof(add_record_params));
    
	add_record_params.uuid                = 0x411C;
	add_record_params.uuid_type           = ble_uuid.type; 
	add_record_params.max_len             = MAX_RECORD_LEN;
	add_record_params.init_len            = record_encode(&record_initial_value, record_encoded_value);
	add_record_params.p_init_value        = record_encoded_value; 
	add_record_params.char_props.notify   = 1; 
	add_record_params.char_props.read     = 1; 
	add_record_params.read_access         = SEC_OPEN; 
	add_record_params.cccd_write_access   = SEC_OPEN;
	// 1 for variable length and 0 for fixed length.
	add_record_params.is_var_len          = 1; 

	err_code = characteristic_add(p_display_service->service_handle, &add_record_params, &(p_display_service->record_handles));
	if (err_code != NRF_SUCCESS)
	{
		return err_code;
	} 

	return NRF_SUCCESS;
}

/**@brief Function for setting the Record. */
uint32_t ble_display_service_record_set(ble_display_service_t * p_display_service, ble_display_service_record_t * p_record)
{
	ble_gatts_value_t gatts_value;
	uint8_t encoded_value[MAX_RECORD_LEN];

	    // Initialize value struct.
	memset(&gatts_value, 0, sizeof(gatts_value));

	gatts_value.len     = record_encode(p_record, encoded_value);
	gatts_value.offset  = 0;
	gatts_value.p_value = encoded_value;

	return sd_ble_gatts_value_set(p_display_service->conn_handle, p_display_service->record_handles.value_handle, &gatts_value);
}

/**@brief Function for sending the Record. */
uint32_t ble_display_service_record_send(ble_display_service_t * p_display_service, ble_display_service_record_t * p_record)
{
	uint32_t err_code = NRF_SUCCESS;

	if (p_display_service->conn_handle != BLE_CONN_HANDLE_INVALID)
	{
		ble_gatts_hvx_params_t hvx_params;
		uint8_t encoded_value[MAX_RECORD_LEN];
		uint16_t hvx_len;

		        // Initialize value struct.
		memset(&hvx_params, 0, sizeof(hvx_params));

		hvx_len           = record_encode(p_record, encoded_value);
		hvx_params.handle = p_display_service->record_handles.value_handle;
		hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
		hvx_params.p_len  = &hvx_len;
		hvx_params.offset = 0;
		hvx_params.p_data = encoded_value;

		err_code = sd_ble_gatts_hvx(p_display_service->conn_handle, &hvx_params);
	}
	else
	{
		err_code = NRF_ERROR_INVALID_STATE;
	}

	return err_code;
}

